@using System.Dynamic
@using System.Text.Json
@using JSONRising.Components
@using JSONRising.Components.Inputs
@using JSONRising.Models;

<div class="schema-editor">
    @foreach (var field in Schema.Fields)
    {
        var fieldValue = GetFieldValue(field.Path);
        <DynamicComponent Type="@GetComponentType(field.ComponentType)"
            Parameters="@GetComponentParameters(field, fieldValue)" />
    }
</div>

@code {
    [Parameter] 
    public JsonSchema Schema { get; set; }
    
    [Parameter] 
    public string JsonContent { get; set; }

    [Parameter]
    public EventCallback<string> JsonContentChanged { get; set; }

    private Type GetComponentType(string componentType)
    {
        return componentType switch
        {
            "FilterList" => typeof(FilterListInput),
            _ => throw new ArgumentException($"Unknown component type: {componentType}")
        };
    }
    private Dictionary<string, object> GetComponentParameters(SchemaField field, object currentValue)
    {
        var parameters = new Dictionary<string, object>();

        var typedValue = currentValue as List<string> ?? new List<string>();
        parameters["Value"] = typedValue;

        parameters["ValueChanged"] = EventCallback.Factory.Create<List<string>>(this, async (value) =>
        {
            await UpdateFieldValue(field.Path, value);
        });

        return parameters;
    }

    private object GetFieldValue(string jsonPath)
    {
        try 
        {
            using JsonDocument doc = JsonDocument.Parse(JsonContent);
            JsonElement root = doc.RootElement;
            
            // Remove the $ and split the path
            string[] pathParts = jsonPath.TrimStart('$', '.').Split('.');
            JsonElement current = root;

            // Navigate to the correct element
            foreach (var part in pathParts)
            {
                if (!current.TryGetProperty(part, out current))
                {
                    return new List<string>();
                }
            }

            // Convert array to List<string>
            if (current.ValueKind == JsonValueKind.Array)
            {
                return current.EnumerateArray()
                    .Select(e => e.GetString())
                    .Where(s => s != null)
                    .ToList();
            }

            return new List<string>();
        }
        catch
        {
            return new List<string>();
        }
    }

    private async Task UpdateFieldValue(string path, object value)
    {
        using var doc = JsonDocument.Parse(JsonContent);
        var root = doc.RootElement.Clone();

        // Create new JSON with updated value
        var options = new JsonSerializerOptions { WriteIndented = true };
        JsonContent = JsonSerializer.Serialize(root, options);

        StateHasChanged();
    }
}